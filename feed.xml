<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://hongyanji.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://hongyanji.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2025-12-04T02:54:22+00:00</updated><id>https://hongyanji.github.io/feed.xml</id><title type="html">Hongyan Ji</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">Time Encoding</title><link href="https://hongyanji.github.io/blog/2025/math/" rel="alternate" type="text/html" title="Time Encoding"/><published>2025-01-01T15:12:00+00:00</published><updated>2025-01-01T15:12:00+00:00</updated><id>https://hongyanji.github.io/blog/2025/math</id><content type="html" xml:base="https://hongyanji.github.io/blog/2025/math/"><![CDATA[<h2 id="kt-1-congest-model-exponential-round-algorithm-with-õn-messages">KT-1 CONGEST Model: Exponential-Round Algorithm with Õ(n) Messages</h2> <ol> <li> <p><strong>Build a spanning tree</strong><br/> Construct a spanning tree \(T\) in \(\tilde{O}(n)\) rounds/messages.</p> </li> <li> <p><strong>Elect a leader</strong><br/> Choose a leader at the root of \(T\). Every node learns its distance from the leader.</p> </li> <li> <p><strong>Enumerate possible graphs</strong><br/> With an ID space of size \(n^c\), there are exponentially many possible graphs.<br/> Each permutation of node IDs defines a different candidate graph.</p> </li> <li><strong>Convergecast process</strong><br/> Let \(E\) be the enumeration of these permutations.<br/> The algorithm runs for \(d\) iterations (where \(d\) is the tree’s depth), and each iteration has \(t\) rounds: <ul> <li><strong>Iteration 1:</strong> Leaves send 1-bit signals to their parents indicating whether their neighborhood matches graph \(E_1\).</li> <li><strong>Subsequent rounds:</strong> Repeat the check for \(E_2, E_3, \dots, E_t\).</li> <li><strong>Iteration i &gt; 1:</strong> Nodes at distance \(d - i + 1\) send bits upward, encoding both their neighborhoods and info received from children.</li> <li>This way, the root gradually reconstructs the entire graph topology.</li> </ul> </li> <li> <p><strong>Root learns the graph</strong><br/> After \(d\) iterations, the root \(u_*\) has complete knowledge of the graph.</p> </li> <li> <p><strong>Broadcast back</strong><br/> The root then disseminates this knowledge down the tree in another \(d\) iterations, using only \(\tilde{O}(n)\) messages.</p> </li> <li><strong>Solve the problem</strong><br/> Finally, each node locally computes the solution from the reconstructed topology.</li> </ol> ]]></content><author><name></name></author><category term="messages"/><category term="algorithm"/><summary type="html"><![CDATA[KT-1 CONGEST model message-efficient algorithm]]></summary></entry></feed>